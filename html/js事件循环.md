## JS事件循环和node事件循环

***node和js都保持了单线程的特点，javascript在最初设计时设计成了单线程,为什么不是多线程呢？如果多个线程同时操作DOM那岂不会很混乱？***

---

### JS事件循环

首先我们要知道js是干嘛的，和用户通过浏览器进行交互，如果同时两个任务操作一个dom，那不就乱套了。**单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务**

>但是呢，随着技术的进步，单线程确实限制了javascript的发展，所以因此出现了一个叫web worker的东西，从表面上来说是把javascript做成了多线程语言（为什么说是表面上，因为web orker 是受主线程控制的，等同于子线程，只能做一些次要的计算，处理数据的任务，无法操作I/O，本质上javascript还是单线程语言）

关于流程我画了幅图：

![image](./image/event_loop.png)

1. 首先所有同步任务都在主线程上执行，形成一个执行栈（就是那个大圆筒里面的stack，里面存在同步任务）。

2. 在这个主线程之外，存在一个事件队列，只要异步任务有了结果，就往事件队列里面放置一个任务。（比如说setTimeout时间到了，就往队列里面放执行的函数）

3. 如果执行栈中的任务执行完毕，就会去读取任务队列，推入栈，继续执行。

4. js是单线程的，但是浏览器是多线程的，不同的异步任务是由不同的浏览器内核的模块来执行的 
>onclick 由浏览器内核的 DOM Binding ；setTimeout 会由浏览器内核的 timer 模块；ajax 则会由浏览器内核的 network 模块

5. event loop里面至少有两个队列，一个是macrotask(宏任务),一个是microtask(微任务)。读取任务队列的时候会优先读取微任务，然后执行完之后才会读取宏任务 （ps: 特别的，如果微任务在执行过程中，又有微任务进了队列，执行完之后，还会优先读取微任务，直到所有微任务读取完，才会读取宏任务 ~~~ 没错 就是这么卑微...）


### node的事件循环

node的事件循环要比浏览器中的要复杂一点，node中事件循环的实现是依靠的libuv引擎（因为没有浏览器嘛~）。

