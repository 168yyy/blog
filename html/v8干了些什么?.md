
## v8干了些什么？

V8是被设计用来提高网页浏览器内部JavaScript执行的性能，那么如何提高性能呢？接下来我们一个个介绍它干了些什么。

--- 
### JIT

说到v8首先我们要明白什么是解释型语言和编译型语言。

- 编译型语言，如c/c++，处理该语言实际上使用编译器直接将它们编译成本地代码，所以在使用的时候已经是可以执行代码，所以速度更快
- 解释型语言，与编译型语言不同的是它需要一遍执行一边解析

**Js语言到底是解释型语言还是编译型语言？**

就像我们刚学js的时候总会听到说js是一门解释型语言，但是v8出现后，还能算吗？

JIT是什么？ 
> JIT（Just-in-time）及时编译编译器，***编译***划重点，不是说是解释型语言吗？为什么还要编译..  这就是v8的一个优化速度的方式了，通过JIT及时编译的方式。

```
for(i=0; i < 1000; i++){
    sum += i;
}
```
编译型的语言直接把它编译成机器码，直接可以运行1000次。  
解释型语言执行时会将sum += i转换（编译）一千次。对相同的代码进行一千次转换会造成非常大的性能损耗。  
> 从上面的例子就可以看出，为什么要加入JIT,在javascript中，如果有代码要运行很多次，JIT 将把这段代码送到编译器中编译并且保存一个编译后的版本。下一次同样代码执行的时候，引擎会跳过翻译过程直接使用编译后的版本。而在真正的编译型语言中，编译器做的比JIT多的多了。

所以JIT是一个优化性能的工具，所以我觉得javascript是一个解释和编译混合的语言（或者可以称作解释型的编译语言）

---
### 隐藏类

javascript是动态语言(TS不算哈... )，由于是动态语言呢，类型不确定，每次都要去动态查询，这就造成大量的性能消耗，从而降低程序运行的速度。V8引擎为了优化这个，引入了隐藏类这个机制，针对**对象**进行分组。初始化个对象的时候会侯，**会同时生成一个隐藏类或者查找之前已经生成的隐藏类。**  

我们看一个例子：
```
let Obj = (name,time)=>{
  this.name = name
  this.time = time
}

let obj1 = new Obj('eric','1993') // 1
let obj2 = new Obj('ming','1994') // 2

obj1.age = '26' // 3
obj1.height = "180" // 4

obj2.height = "170" //5
obj2.age = "25" // 6
```
分析下上段代码，其中的隐藏类的一部分用伪代码表示

- 1和2开始都是初始化一个Obj，然后会v8会生成一个隐藏类C0，然后同时会加入两个属性（name,time)，因为属性是相同的，所以在C0的基础生会生成一个C1和C2的过渡隐藏类。
C1 = `Obj{name}`,C2 = `Obj{name,time}`

- 再看3和4，obj1添加了两个属性（age,height）所以会在C2的基础上生成C3和C4的隐藏类。C3 = `obj{name,time,age}`, C4 = `obj{name,time,age,height}`

- 再看5和6，obj2添加了两个属性（height,age）因为属性的添加顺序和obj1不同，首先会去找`Obj{name,time,height}`的隐藏类，发现没有，所以在C2的基础上添加一个C5的隐藏类，然后寻找`Obj{name,time,height,age}`发现还是没有，所以在C5的基础上添加一个C6的隐藏类。
C5 = `obj{name,time,height}` , C6 = `obj{name,time,heightage}`

>不同初始化顺序的对象，所生成的隐藏类是不一样的。因此，在实际开发过程中，应该尽量保证属性初始化的顺序一致，这样生成的隐藏类可以得到共享。同时，尽量在构造函数里就初始化所有对象成员，减少隐藏类的产生。

---

### 内联缓存


### 垃圾回收
IE9以下的js引擎对非原生对象（如BOM，DOM）的垃圾回收会采用引用计数算法，

传统的Gc（垃圾收集）

- 标记清除法

- 引用计数法


V8的Gc

在V8中，将内存分为了新生代（new space）和老生代（old space）。

- 新生代内存回收Scavenge算法

- 老生代内存回收 标记清除法